{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","categories","className","placeholder","type","value","onChange","target","getGifs","category","a","limit","url","encodeURI","fetch","resp","json","data","stickers","map","img","id","title","images","downsized_medium","GifGridItem","src","alt","GifGrid","loading","state","setstate","useEffect","then","useFetchGifs","image","key","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"+MAIaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAGRC,mBAAS,IAHD,mBAGtCC,EAHsC,KAG1BC,EAH0B,KAyB9C,OAEI,0BAAMC,SAfW,SAACC,GAClBA,EAAEC,iBAEGJ,EAAWK,OAAOC,OAAS,IAG5BR,GAAe,SAAAS,GAAU,OAAMP,GAAN,mBAAqBO,OAE9CN,EAAc,OAQd,2BACIO,UAAU,eACVC,YAAY,iBACZC,KAAK,OACLC,MAAQX,EACRY,SA3Bc,SAACT,GAEvBF,EAAeE,EAAEU,OAAOF,Y,uBCXnBG,EAAO,uCAAG,WAAMC,GAAN,qCAAAC,EAAA,6DAAgBC,EAAhB,+BAAwB,GAKrCC,EALa,iDAKoCC,UAAWJ,GAL/C,kBAKqEE,EALrE,sDAMAG,MAAMF,GANN,cAMbG,EANa,gBAOIA,EAAKC,OAPT,uBAOXC,EAPW,EAOXA,KAIFC,EAAWD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EAC7B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAfvB,kBAoBZM,GApBY,4CAAH,sDCCPO,EAAc,SAAC,GAAoB,IAAlBH,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAGjC,OACI,oCACA,yBAAKV,UAAU,kDACX,yBAAKA,UAAU,eAAewB,IAAMd,EAAMe,IAAML,IAChD,yBAAKpB,UAAU,aACX,wBAAIA,UAAU,cAAd,IAA8BoB,EAA9B,SCLHM,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECCb,SAAEA,GAAe,IAAD,EAEdhB,mBAAS,CAC/BwB,KAAM,GACNY,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KA6BxC,OAbAC,qBAAW,WAEPxB,EAASC,GAAWwB,MAAM,SAAAV,GAEtBQ,EAAS,CACLd,KAAMM,EACNM,SAAS,SAKlB,CAACpB,IAEGqB,ED1B2BI,CAAczB,GAAlCc,EAJuB,EAI7BN,KAAcY,EAJe,EAIfA,QAUtB,OAEI,oCACI,wBAAI3B,UAAU,qDAAd,IAAqEO,EAArE,KAIEoB,GAAW,uBAAG3B,UAAU,+CAAb,cAEb,yBAAKA,UAAU,gBAGPqB,EAAOJ,KAAK,SAACgB,GACT,OAAO,kBAAC,EAAD,eAAaC,IAAMD,EAAMd,IAAUc,UEQnDE,EAnCM,WAAM,MAIe5C,mBAAS,CAAC,mBAJzB,mBAIfQ,EAJe,KAIHT,EAJG,KAgBvB,OACI,kBAAC,WAAD,KACI,wBAAIU,UAAU,mBAAd,gBACA,kBAAC,EAAD,CAAaV,cAAgBA,IAC7B,6BAGIS,EAAWkB,KAAK,SAAAV,GAIZ,OAAO,kBAAC,EAAD,CAAS2B,IAAM3B,EAAWA,SAAWA,SC1BhE6B,IAASC,OACL,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.9860d6b0.chunk.js","sourcesContent":["//  snippet con rafc\r\nimport React, { useState } from 'react'\r\nimport PropTypes from 'prop-types'; //  importamos para definir tipo de datos de props\r\n\r\nexport const AddCategory = ({ setCategories }) => {\r\n\r\n    //  si no definimos un valor por defecto para el useState será undefined\r\n    const [ inputValue, setInputValue ] = useState(''); //  string  vacio\r\n\r\n\r\n    const handleInputChange = (e) => {\r\n        \r\n        setInputValue( e.target.value );\r\n    }\r\n\r\n\r\n    const handleSubmit = (e) => {\r\n        e.preventDefault();\r\n        //  evaluamos si el largo del valor ingresado es mayor a 2\r\n        if ( inputValue.trim().length > 2 ) {\r\n\r\n            //  setCategories puede ejecutar un callback\r\n            setCategories( categories => [ inputValue, ...categories, ] );\r\n            //  evitamos un doble posteo\r\n            setInputValue('');\r\n        }\r\n    }\r\n\r\n    //  cuando existe un elemento que envuelve a los demás elementos no es necesario poner la etiqueta fragment\r\n    return (\r\n        \r\n        <form onSubmit={ handleSubmit }>\r\n            <input\r\n                className=\"form-control\"\r\n                placeholder=\"Buscar gifs...\"\r\n                type=\"text\"\r\n                value={ inputValue }\r\n                onChange={ handleInputChange }\r\n            />\r\n\r\n        </form>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}\r\n","//  retorna una promesa que resuelve la coleccion de imagenes o gifs\r\nexport const getGifs = async(category, limit = 12) => {\r\n\r\n    //  realizamos la petición http para traer los gifs\r\n    //  con encodeURI() de JS escapa los caracteres extraños y reemplaza los espacios por %20, entre otras cosas\r\n    // const url = `https://api.giphy.com/v1/stickers/search?q=${ category }&limit=${ limit }&api_key=w4U0uVyxFyqlZrHTG3P8cJys72GSBsJs`;\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=${ limit }&api_key=w4U0uVyxFyqlZrHTG3P8cJys72GSBsJs`;\r\n    const resp = await fetch(url);\r\n    const { data } = await resp.json();\r\n\r\n    // console.log(data);\r\n\r\n    const stickers = data.map(img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    });\r\n\r\n    // console.log(stickers);\r\n    return stickers;\r\n}","import React from 'react'\r\n\r\nexport const GifGridItem = ({ title, url }) => {\r\n\r\n    // console.log( {id, title, url} );\r\n    return (\r\n        <>\r\n        <div className=\"card animate__animated animate__fadeIn pointer\">\r\n            <img className=\"card-img-top\" src={ url } alt={ title } />\r\n            <div className=\"card-body\">\r\n                <h5 className=\"card-title\"> { title } </h5>\r\n            </div>\r\n        </div>\r\n        </>\r\n    )\r\n}\r\n","// import React, { useState, useEffect } from 'react'\r\nimport React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs'    //  importamos nuestro custom hook\r\n\r\nimport { GifGridItem } from './GifGridItem';\r\nexport const GifGrid = ({ category }) => {\r\n\r\n    //  inicializamos el estado del componente\r\n    // const [images, setImages] = useState([]);\r\n    const { data: images, loading } = useFetchGifs( category );   //  desestructuramos nuesro objeto\r\n\r\n    // console.log( state );\r\n    //  recibe la funcion callback a ejecutar\r\n    //  como segundo argumento recibe la lista de dependencias\r\n    //  para este caso solo queremos que la función se ejecute cuando el componente\r\n    //  es renderizado por primera vez\r\n\r\n    \r\n\r\n    return (\r\n\r\n        <>\r\n            <h3 className=\"text-light my-4 animate__animated animate__fadeIn\"> { category } </h3>\r\n\r\n            {/* Utilizamos la forma corta del operador ternario */}\r\n\r\n            { loading && <p className=\"text-light animate__animated animate__pulse\">Loading...</p> }\r\n\r\n            <div className=\"card-columns\">\r\n\r\n                {\r\n                    images.map( (image) => {\r\n                        return <GifGridItem key={ image.id } { ...image } />\r\n                    })\r\n                }\r\n\r\n                {/* <ol> */}\r\n                    {/* {\r\n                        images.map( image => {\r\n                            return <li key={ image.id } > { image.title } </li>\r\n                        })\r\n                    } */}\r\n\r\n                    {/* Podemos utilizar la desestructuración de objetos */}\r\n                    {/* {\r\n                        images.map( ({ id, title }) => (\r\n                            <li key={ id } > { title } </li>\r\n                        ))\r\n                    } */}\r\n                {/* </ol> */}\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n","//  los hooks son solo funciones\r\n//  los hooks tambien pueden tener su estado\r\n//  los hooks tambien pueden ejecutar efectos\r\nimport { useState, useEffect } from \"react\";\r\nimport { getGifs } from \"../helpers/getGifs\";\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    const [state, setstate] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    // useEffect( () => {\r\n    //     //  llamamos nuestra funcion\r\n    //     getGifs( category ).then( images => {\r\n\r\n    //         return setImages( images );\r\n    //     });\r\n\r\n    // }, [ category ]);\r\n\r\n    useEffect( () => {\r\n\r\n        getGifs( category ).then( images => {\r\n            \r\n            setstate({\r\n                data: images,\r\n                loading: false\r\n            });\r\n\r\n        })\r\n        \r\n    }, [category])\r\n\r\n    return state; //    { data: [], loading: true }\r\n\r\n}","import React, { Fragment, useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n\r\nconst GifExpertApp = () => {\r\n\r\n\r\n    // const categories = ['one Punch', 'Samurai X', 'Dragon Ball'];\r\n    const [ categories, setCategories ] = useState(['Rick and Morty']);\r\n\r\n\r\n    // const handAdd = () => {\r\n    //     //  forma 1 spread operator\r\n    //     // setCategories( [...categories, 'Fullmetal Alchemist Brotherhoods'] );\r\n    //     //  forma 2 callback + spread operator\r\n    //     setCategories( elements => [ ...elements, 'Fullmetal Alchemist Brotherhoods' ]);\r\n    // }\r\n\r\n\r\n\r\n    return (\r\n        <Fragment>\r\n            <h2 className=\"text-white mb-4\">GifExpertApp</h2>\r\n            <AddCategory setCategories={ setCategories } />\r\n            <hr/>\r\n\r\n            { \r\n                categories.map( category => {\r\n\r\n                    // return <li key={ category }> { category } </li>;\r\n                    //  utilizamos nuestro componente\r\n                    return <GifGrid key={ category } category={ category } />\r\n                })\r\n            }\r\n        </Fragment>\r\n    )\r\n}\r\n\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport GifExpertApp from './GifExpertApp';\n\nReactDOM.render(\n    <GifExpertApp />,\n    document.getElementById('root')\n);"],"sourceRoot":""}